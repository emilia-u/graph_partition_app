package org.example;
import org.example.model.PartitionResult;
import org.example.model.Graph;

import javax.swing.*;
import javax.swing.table.DefaultTableModel;
import java.awt.*;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

public class DetailsUI {
    private JPanel technicalPanel;
    private JButton backButton;
    private JTable adjacencyTable;
    private JLabel text1;
    private JLabel text2;
    private JTable adjacencyTablePostPartition;
    private Graph graph;
    private List<PartitionResult.PartitionInfo> partitionResults;  // Changed type
    private List<Integer>[] originalNeighbors;

    public DetailsUI(Graph graph, List<Integer>[] originalNeighborsList) {
        this.graph = graph;
        this.partitionResults = null;
        // Zapisz kopię oryginalnej listy sąsiedztwa
        this.originalNeighbors = new ArrayList[graph.getNumVertices()];
        for (int i = 0; i < graph.getNumVertices(); i++) {
            this.originalNeighbors[i] = new ArrayList<>(originalNeighborsList[i]);
        }
        initializeTables();
    }

    public void setPartitionResults(List<PartitionResult.PartitionInfo> results) {
        this.partitionResults = results;
        initializeTables();
    }

    private List<Integer>[] deepCopyNeighbors(List<Integer>[] neighbors) {
        if (neighbors == null || graph == null) return null;

        @SuppressWarnings("unchecked")
        List<Integer>[] copy = new List[graph.getNumVertices()];
        for (int i = 0; i < graph.getNumVertices(); i++) {
            if (neighbors[i] != null) {
                copy[i] = new ArrayList<>(neighbors[i]);
            } else {
                copy[i] = new ArrayList<>();
            }
        }
        return copy;
    }

    // Nowa metoda do aktualizacji z zachowaniem oryginalnego stanu
    public void updateData(Graph newGraph, List<PartitionResult.PartitionInfo> results, List<Integer>[] originalNeighbors) {
        this.graph = newGraph;
        this.partitionResults = results;
        this.originalNeighbors = deepCopyNeighbors(originalNeighbors);
        initializeTables();
    }

    private void initializeTables() {
        showOriginalGraphTable();
        showPartitionedGraphTable();
    }

    private void showOriginalGraphTable() {
        DefaultTableModel model = new DefaultTableModel(
                new Object[]{"Wierzchołek", "Lista sąsiedztwa"}, 0);

        if (originalNeighbors != null && graph != null) {
            for (int i = 0; i < graph.getNumVertices(); i++) {
                StringBuilder adjacencyStr = new StringBuilder();
                List<Integer> neighbors = originalNeighbors[i];

                if (neighbors.isEmpty()) {
                    adjacencyStr.append("[]");
                } else {
                    adjacencyStr.append("[");
                    for (int j = 0; j < neighbors.size(); j++) {
                        adjacencyStr.append(neighbors.get(j));
                        if (j < neighbors.size() - 1) {
                            adjacencyStr.append(", ");
                        }
                    }
                    adjacencyStr.append("]");
                }

                model.addRow(new Object[]{
                        String.format("Vertex %d", i),
                        adjacencyStr.toString()
                });
            }
        }

        adjacencyTable.setModel(model);
        configureTable(adjacencyTable, new int[]{80, 200});
    }

    private void showPartitionedGraphTable() {
        DefaultTableModel model = new DefaultTableModel(
                new Object[]{"Grupa", "Wierzchołek", "Lista sąsiedztwa"}, 0);

        if (partitionResults != null && !partitionResults.isEmpty()) {
            PartitionResult.PartitionInfo lastResult = partitionResults.get(partitionResults.size() - 1);

            for (Map.Entry<Integer, List<Integer>> entry : lastResult.getComponentVertices().entrySet()) {
                int groupId = entry.getKey();
                List<Integer> vertices = entry.getValue();

                // Dla każdego wierzchołka w grupie dodaj osobny wiersz
                for (int vertex : vertices) {
                    model.addRow(new Object[]{
                            groupId,
                            vertex,
                            graph.getNeighbors()[vertex].toString()
                    });
                }
            }
        }

        adjacencyTablePostPartition.setModel(model);
        configureTable(adjacencyTablePostPartition, new int[]{60, 80, 200});
    }

    public JPanel getPanel() {
        return technicalPanel;
    }

    public JButton getBackButton() {
        return backButton;
    }

    {
// GUI initializer generated by IntelliJ IDEA GUI Designer
// >>> IMPORTANT!! <<<
// DO NOT EDIT OR ADD ANY CODE HERE!
        $$$setupUI$$$();
    }

    /**
     * Method generated by IntelliJ IDEA GUI Designer
     * >>> IMPORTANT!! <<<
     * DO NOT edit this method OR call it in your code!
     *
     * @noinspection ALL
     */
    private void $$$setupUI$$$() {
        technicalPanel = new JPanel();
        technicalPanel.setLayout(new com.intellij.uiDesigner.core.GridLayoutManager(3, 3, new Insets(10, 10, 10, 10), -1, -1));
        backButton = new JButton();
        backButton.setForeground(new Color(-4488797));
        backButton.setText("Powrót do ekranu głównego");
        technicalPanel.add(backButton, new com.intellij.uiDesigner.core.GridConstraints(2, 2, 1, 1, com.intellij.uiDesigner.core.GridConstraints.ANCHOR_EAST, com.intellij.uiDesigner.core.GridConstraints.FILL_NONE, com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_CAN_SHRINK | com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_CAN_GROW, com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));
        final com.intellij.uiDesigner.core.Spacer spacer1 = new com.intellij.uiDesigner.core.Spacer();
        technicalPanel.add(spacer1, new com.intellij.uiDesigner.core.GridConstraints(2, 0, 1, 1, com.intellij.uiDesigner.core.GridConstraints.ANCHOR_CENTER, com.intellij.uiDesigner.core.GridConstraints.FILL_HORIZONTAL, com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_WANT_GROW, 1, null, null, null, 0, false));
        text1 = new JLabel();
        text1.setForeground(new Color(-4488797));
        text1.setText("lista sąsiedztwa przed podziałem");
        technicalPanel.add(text1, new com.intellij.uiDesigner.core.GridConstraints(0, 0, 1, 1, com.intellij.uiDesigner.core.GridConstraints.ANCHOR_CENTER, com.intellij.uiDesigner.core.GridConstraints.FILL_NONE, com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_FIXED, com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));
        final com.intellij.uiDesigner.core.Spacer spacer2 = new com.intellij.uiDesigner.core.Spacer();
        technicalPanel.add(spacer2, new com.intellij.uiDesigner.core.GridConstraints(1, 1, 1, 1, com.intellij.uiDesigner.core.GridConstraints.ANCHOR_CENTER, com.intellij.uiDesigner.core.GridConstraints.FILL_VERTICAL, 1, com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_WANT_GROW, null, null, null, 0, false));
        text2 = new JLabel();
        text2.setForeground(new Color(-4488797));
        text2.setText("lista sąsiedztwa po podziałe");
        technicalPanel.add(text2, new com.intellij.uiDesigner.core.GridConstraints(0, 2, 1, 1, com.intellij.uiDesigner.core.GridConstraints.ANCHOR_CENTER, com.intellij.uiDesigner.core.GridConstraints.FILL_NONE, com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_FIXED, com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));
        final JScrollPane scrollPane1 = new JScrollPane();
        scrollPane1.setForeground(new Color(-1381654));
        scrollPane1.setInheritsPopupMenu(false);
        technicalPanel.add(scrollPane1, new com.intellij.uiDesigner.core.GridConstraints(1, 0, 1, 1, com.intellij.uiDesigner.core.GridConstraints.ANCHOR_CENTER, com.intellij.uiDesigner.core.GridConstraints.FILL_BOTH, com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_CAN_SHRINK | com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_WANT_GROW, com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_CAN_SHRINK | com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_WANT_GROW, null, null, null, 0, false));
        adjacencyTable = new JTable();
        scrollPane1.setViewportView(adjacencyTable);
        final JScrollPane scrollPane2 = new JScrollPane();
        scrollPane2.setForeground(new Color(-1381654));
        technicalPanel.add(scrollPane2, new com.intellij.uiDesigner.core.GridConstraints(1, 2, 1, 1, com.intellij.uiDesigner.core.GridConstraints.ANCHOR_CENTER, com.intellij.uiDesigner.core.GridConstraints.FILL_BOTH, com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_CAN_SHRINK | com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_WANT_GROW, com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_CAN_SHRINK | com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_WANT_GROW, null, null, null, 0, false));
        adjacencyTablePostPartition = new JTable();
        scrollPane2.setViewportView(adjacencyTablePostPartition);
    }

    /**
     * @noinspection ALL
     */
    public JComponent $$$getRootComponent$$$() {
        return technicalPanel;
    }

    public void setOriginalNeighbors(List<Integer>[] neighbors) {
        if (neighbors == null || graph == null) return;

        this.originalNeighbors = new ArrayList[graph.getNumVertices()];
        for (int i = 0; i < graph.getNumVertices(); i++) {
            this.originalNeighbors[i] = new ArrayList<>(neighbors[i]);
        }
        initializeTables();
    }

    private void configureTable(JTable table, int[] columnWidths) {
        table.setRowHeight(25);
        for (int i = 0; i < columnWidths.length && i < table.getColumnCount(); i++) {
            table.getColumnModel().getColumn(i).setPreferredWidth(columnWidths[i]);
        }
        // Opcjonalne ustawienia dla lepszego wyglądu
        table.setAutoResizeMode(JTable.AUTO_RESIZE_LAST_COLUMN);
        table.getTableHeader().setReorderingAllowed(false);
    }
}